SQL in R
================

# What is SQL?

SQL (Structured Query Language) is a standard programming language
specifically designed for managing and manipulating relational
databases. It allows users to perform various operations such as
querying data, updating records, inserting new data, and deleting
existing data.

# Why use SQL in R?

Using SQL in R allows for efficient data manipulation and analysis,
especially when dealing with large datasets. It provides a powerful way
to filter, aggregate, and transform data directly within the R
environment, leveraging the strengths of both SQL and R.

# packages available for using sql in R

``` r
library(DBI)
library(RSQLite)
library(dplyr)
library(dbplyr)
library(sqldf)
```

# By using SQLdf

``` r
library(sqldf)
data=iris
result <- sqldf("SELECT * 
                FROM data 
                WHERE Species = 'setosa'
                ORDER BY [Sepal.Length] DESC")
head(result)
```

    ##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
    ## 1          5.8         4.0          1.2         0.2  setosa
    ## 2          5.7         4.4          1.5         0.4  setosa
    ## 3          5.7         3.8          1.7         0.3  setosa
    ## 4          5.5         4.2          1.4         0.2  setosa
    ## 5          5.5         3.5          1.3         0.2  setosa
    ## 6          5.4         3.9          1.7         0.4  setosa

# By using DBI and RSQLite

``` r
library(DBI)
library(RSQLite)
# Create a SQLite database connection
con <- dbConnect(RSQLite::SQLite(), ":memory:")
# Write the iris dataset to the database
dbWriteTable(con, "iris", iris)
# Query the database using SQL
result1 <- dbGetQuery(con, "SELECT * 
                            FROM iris 
                            WHERE Species = 'setosa' 
                            ORDER BY [Sepal.Length] DESC")
head(result1)
```

    ##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
    ## 1          5.8         4.0          1.2         0.2  setosa
    ## 2          5.7         4.4          1.5         0.4  setosa
    ## 3          5.7         3.8          1.7         0.3  setosa
    ## 4          5.5         4.2          1.4         0.2  setosa
    ## 5          5.5         3.5          1.3         0.2  setosa
    ## 6          5.4         3.9          1.7         0.4  setosa

``` r
# Disconnect from the database
dbDisconnect(con)
```

make sure to disconnect from the database after you are done to free up
resources.

# By using dplyr and dbplyr

this package allows you to use SQL-like syntax with dplyr functions.

``` r
library(dplyr)
library(dbplyr)
library(RSQLite)
library(DBI)
library(tidyverse)
```

``` r
# Create a SQLite database connection
con <- dbConnect(RSQLite::SQLite(), ":memory:")
# Write the iris dataset to the database
copy_to(con, iris, "iris", temporary = FALSE, overwrite = TRUE)
#  extract the table from con
iris_tbl <- tbl(con, "iris")

# applying dplyr functions
 iris_tbl %>% 
  group_by(Species) %>% arrange(desc(Sepal.Length)) %>%
  mutate(rank=row_number()) %>% 
  filter(rank==2) %>% select(-rank)
```

    ## Warning: ORDER BY is ignored in subqueries without LIMIT
    ## ℹ Do you need to move arrange() later in the pipeline or use window_order() instead?

    ## # Source:     SQL [?? x 5]
    ## # Database:   sqlite 3.50.1 [:memory:]
    ## # Groups:     Species
    ## # Ordered by: desc(Sepal.Length)
    ##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species   
    ##          <dbl>       <dbl>        <dbl>       <dbl> <chr>     
    ## 1          5.7         4.4          1.5         0.4 setosa    
    ## 2          6.9         3.1          4.9         1.5 versicolor
    ## 3          7.7         3.8          6.7         2.2 virginica

to know the sql query generated by dplyr, you can use the `show_query()`
function or `sql_render()` function from dbplyr.

``` r
iris_tbl %>% 
  group_by(Species) %>% arrange(desc(Sepal.Length)) %>%
  mutate(rank=row_number()) %>% 
  filter(rank==2) %>% select(-rank) %>% show_query()
```

    ## Warning: ORDER BY is ignored in subqueries without LIMIT
    ## ℹ Do you need to move arrange() later in the pipeline or use window_order() instead?

    ## <SQL>
    ## SELECT `Sepal.Length`, `Sepal.Width`, `Petal.Length`, `Petal.Width`, `Species`
    ## FROM (
    ##   SELECT
    ##     `iris`.*,
    ##     ROW_NUMBER() OVER (PARTITION BY `Species` ORDER BY `Sepal.Length` DESC) AS `rank`
    ##   FROM `iris`
    ## ) AS `q01`
    ## WHERE (`rank` = 2.0)

``` r
iris_tbl %>% 
  group_by(Species) %>% arrange(desc(Sepal.Length)) %>%
  mutate(rank=row_number()) %>% 
  filter(rank==2) %>% select(-rank) %>% sql_render()
```

    ## Warning: ORDER BY is ignored in subqueries without LIMIT
    ## ℹ Do you need to move arrange() later in the pipeline or use window_order() instead?

    ## <SQL> SELECT `Sepal.Length`, `Sepal.Width`, `Petal.Length`, `Petal.Width`, `Species`
    ## FROM (
    ##   SELECT
    ##     `iris`.*,
    ##     ROW_NUMBER() OVER (PARTITION BY `Species` ORDER BY `Sepal.Length` DESC) AS `rank`
    ##   FROM `iris`
    ## ) AS `q01`
    ## WHERE (`rank` = 2.0)

# joins in R programming

| Join Function | Type | Description |
|----|----|----|
| `inner_join()` | Mutating Join | Returns only rows with matching keys in both data frames |
| `left_join()` | Mutating Join | Returns all rows from the left data frame, adds matching from the right |
| `right_join()` | Mutating Join | Returns all rows from the right data frame, adds matching from the left |
| `full_join()` | Mutating Join | Returns all rows from both data frames, with `NA`s where no match |
| `semi_join()` | Filtering Join | Returns rows from the left where there are matches in the right (no columns from right) |
| `anti_join()` | Filtering Join | Returns rows from the left where there are **no** matches in the right |
| `nest_join()` | Nested Join | Adds a list-column of matching rows from the right data frame |

# example of joins in R

``` r
# Left table: students
students <- tibble(
  student_id = c(1, 2, 3, 4),
  name = c("Alice", "Bob", "Charlie", "David")
)

# Right table: marks
marks <- tibble(
  student_id = c(2, 3, 4, 5),
  score = c(85, 90, 95, 80)
)
```

``` r
# INNER JOIN: only matching student_id in both
inner_join(students, marks, by = "student_id")
```

    ## # A tibble: 3 × 3
    ##   student_id name    score
    ##        <dbl> <chr>   <dbl>
    ## 1          2 Bob        85
    ## 2          3 Charlie    90
    ## 3          4 David      95

``` r
# LEFT JOIN: all students, scores if matched
left_join(students, marks, by = "student_id")
```

    ## # A tibble: 4 × 3
    ##   student_id name    score
    ##        <dbl> <chr>   <dbl>
    ## 1          1 Alice      NA
    ## 2          2 Bob        85
    ## 3          3 Charlie    90
    ## 4          4 David      95

``` r
# RIGHT JOIN: all marks, student info if matched
right_join(students, marks, by = "student_id")
```

    ## # A tibble: 4 × 3
    ##   student_id name    score
    ##        <dbl> <chr>   <dbl>
    ## 1          2 Bob        85
    ## 2          3 Charlie    90
    ## 3          4 David      95
    ## 4          5 <NA>       80

``` r
# FULL JOIN: all records from both
full_join(students, marks, by = "student_id")
```

    ## # A tibble: 5 × 3
    ##   student_id name    score
    ##        <dbl> <chr>   <dbl>
    ## 1          1 Alice      NA
    ## 2          2 Bob        85
    ## 3          3 Charlie    90
    ## 4          4 David      95
    ## 5          5 <NA>       80

``` r
# SEMI JOIN: only students who have marks
semi_join(students, marks, by = "student_id")
```

    ## # A tibble: 3 × 2
    ##   student_id name   
    ##        <dbl> <chr>  
    ## 1          2 Bob    
    ## 2          3 Charlie
    ## 3          4 David

``` r
# ANTI JOIN: students who do NOT have marks
anti_join(students, marks, by = "student_id")
```

    ## # A tibble: 1 × 2
    ##   student_id name 
    ##        <dbl> <chr>
    ## 1          1 Alice

``` r
# NESTED JOIN: returns list-columns of matches
nest_join(students, marks, by = "student_id")
```

    ## # A tibble: 4 × 3
    ##   student_id name    marks           
    ##        <dbl> <chr>   <list>          
    ## 1          1 Alice   <tibble [0 × 1]>
    ## 2          2 Bob     <tibble [1 × 1]>
    ## 3          3 Charlie <tibble [1 × 1]>
    ## 4          4 David   <tibble [1 × 1]>

using self join

``` r
# Sample employee data
employees <- tibble(
  emp_id = c(1, 2, 3, 4),
  name = c("Alice", "Bob", "Charlie", "David"),
  manager_id = c(NA, 1, 1, 2)
)

# Self join to get manager names
employees %>%
  left_join(employees, by = c("manager_id" = "emp_id"), suffix = c("_emp", "_mgr")) 
```

    ## # A tibble: 4 × 5
    ##   emp_id name_emp manager_id name_mgr manager_id_mgr
    ##    <dbl> <chr>         <dbl> <chr>             <dbl>
    ## 1      1 Alice            NA <NA>                 NA
    ## 2      2 Bob               1 Alice                NA
    ## 3      3 Charlie           1 Alice                NA
    ## 4      4 David             2 Bob                   1
