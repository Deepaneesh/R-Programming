---
title: "SQL in R "
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# What is SQL?
SQL (Structured Query Language) is a standard programming language specifically designed for managing and manipulating relational databases. It allows users to perform various operations such as querying data, updating records, inserting new data, and deleting existing data.

# Why use SQL in R?
Using SQL in R allows for efficient data manipulation and analysis, especially when dealing with large datasets. It provides a powerful way to filter, aggregate, and transform data directly within the R environment, leveraging the strengths of both SQL and R.

# packages available for using sql in R
```{r echo=TRUE, message=FALSE, warning=FALSE}
library(DBI)
library(RSQLite)
library(dplyr)
library(dbplyr)
library(sqldf)
```

# By using SQLdf

```{r}
library(sqldf)
data=iris
result <- sqldf("SELECT * 
                FROM data 
                WHERE Species = 'setosa'
                ORDER BY [Sepal.Length] DESC")
head(result)
```
# By using DBI and RSQLite
```{r}
library(DBI)
library(RSQLite)
# Create a SQLite database connection
con <- dbConnect(RSQLite::SQLite(), ":memory:")
# Write the iris dataset to the database
dbWriteTable(con, "iris", iris)
# Query the database using SQL
result1 <- dbGetQuery(con, "SELECT * 
                            FROM iris 
                            WHERE Species = 'setosa' 
                            ORDER BY [Sepal.Length] DESC")
head(result1)
# Disconnect from the database
dbDisconnect(con)
```
make sure to disconnect from the database after you are done to free up resources.

# By using dplyr and dbplyr

this package allows you to use SQL-like syntax with dplyr functions.

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(dbplyr)
library(RSQLite)
library(DBI)
library(tidyverse)
```

```{r}

# Create a SQLite database connection
con <- dbConnect(RSQLite::SQLite(), ":memory:")
# Write the iris dataset to the database
copy_to(con, iris, "iris", temporary = FALSE, overwrite = TRUE)
#  extract the table from con
iris_tbl <- tbl(con, "iris")

# applying dplyr functions
 iris_tbl %>% 
  group_by(Species) %>% arrange(desc(Sepal.Length)) %>%
  mutate(rank=row_number()) %>% 
  filter(rank==2) %>% select(-rank)

```

to know the sql query generated by dplyr, you can use the `show_query()` function or 
`sql_render()` function from dbplyr.

```{r}
iris_tbl %>% 
  group_by(Species) %>% arrange(desc(Sepal.Length)) %>%
  mutate(rank=row_number()) %>% 
  filter(rank==2) %>% select(-rank) %>% show_query()

```

```{r}
iris_tbl %>% 
  group_by(Species) %>% arrange(desc(Sepal.Length)) %>%
  mutate(rank=row_number()) %>% 
  filter(rank==2) %>% select(-rank) %>% sql_render()
```
# joins in R programming 

| Join Function      | Type            | Description                                                                 |
|--------------------|------------------|-----------------------------------------------------------------------------|
| `inner_join()`     | Mutating Join    | Returns only rows with matching keys in both data frames                    |
| `left_join()`      | Mutating Join    | Returns all rows from the left data frame, adds matching from the right     |
| `right_join()`     | Mutating Join    | Returns all rows from the right data frame, adds matching from the left     |
| `full_join()`      | Mutating Join    | Returns all rows from both data frames, with `NA`s where no match           |
| `semi_join()`      | Filtering Join   | Returns rows from the left where there are matches in the right (no columns from right) |
| `anti_join()`      | Filtering Join   | Returns rows from the left where there are **no** matches in the right      |
| `nest_join()`      | Nested Join      | Adds a list-column of matching rows from the right data frame               |


# example of joins in R

```{r}


# Left table: students
students <- tibble(
  student_id = c(1, 2, 3, 4),
  name = c("Alice", "Bob", "Charlie", "David")
)

# Right table: marks
marks <- tibble(
  student_id = c(2, 3, 4, 5),
  score = c(85, 90, 95, 80)
)

```

```{r}
# INNER JOIN: only matching student_id in both
inner_join(students, marks, by = "student_id")

# LEFT JOIN: all students, scores if matched
left_join(students, marks, by = "student_id")

# RIGHT JOIN: all marks, student info if matched
right_join(students, marks, by = "student_id")

# FULL JOIN: all records from both
full_join(students, marks, by = "student_id")

# SEMI JOIN: only students who have marks
semi_join(students, marks, by = "student_id")

# ANTI JOIN: students who do NOT have marks
anti_join(students, marks, by = "student_id")

# NESTED JOIN: returns list-columns of matches
nest_join(students, marks, by = "student_id")


```

using self join 
```{r}
# Sample employee data
employees <- tibble(
  emp_id = c(1, 2, 3, 4),
  name = c("Alice", "Bob", "Charlie", "David"),
  manager_id = c(NA, 1, 1, 2)
)

# Self join to get manager names
employees %>%
  left_join(employees, by = c("manager_id" = "emp_id"), suffix = c("_emp", "_mgr")) 

```

